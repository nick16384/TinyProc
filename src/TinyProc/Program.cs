using TinyProc.Assembler;
using TinyProc.Memory;
using TinyProc.Processor.CPU;

class Program
{
    public static readonly string TINYPROC_VERSION_STR = "0.2025.04";
    static void Main(string[] args)
    {
        Console.WriteLine($"\nTinyProc ver. {TINYPROC_VERSION_STR}");

        Console.WriteLine($"Arguments: {args.Length}");

        if (args.Length != 2
            || (!args[0].Equals("--assemble") && !args[0].Equals("--run")))
        {
            Console.Error.WriteLine(
                "Usage:\n" +
                "--assemble <Source file> : Creates a binary executable file in the same directory.\n" +
                "--run <Executable file> : Runs the executable file generated by the --assemble command.");
            return;
        }

        if (args[0].Equals("--assemble"))
        {
            string sourceFilePath = args[1];
            Console.WriteLine($"Assembling source file {sourceFilePath}");
            if (sourceFilePath.Trim().EndsWith(".lltp-x25-32.asm"))
                Console.Error.WriteLine("Warning: Source file name does not end with standard suffix \".lltp-x25-32.asm\".");
            
            string assemblyCode = File.ReadAllText(sourceFilePath);
            uint[] MAIN_PROGRAM = Assembler.AssembleToMachineCode(assemblyCode);

            string outputBinaryFilePath = sourceFilePath + ".bin";
            if (sourceFilePath.EndsWith(".asm"))
                outputBinaryFilePath = sourceFilePath[..^4] + ".bin";
            FileStream outputBinaryFileStream = File.Open(outputBinaryFilePath, FileMode.Create);
            BinaryWriter binaryWriter = new(outputBinaryFileStream);
            foreach (uint programWord in MAIN_PROGRAM)
                binaryWriter.Write(programWord);
            
            Console.WriteLine($"Binary executable file written at {outputBinaryFilePath}");
            binaryWriter.Close();
            return;
        }

        if (args[0].Equals("--run"))
        {
            string executableFilePath = args[1];
            Console.WriteLine($"Attempting to load and run binary executable {executableFilePath}");
            if (executableFilePath.Trim().EndsWith(".lltp-x25-32.bin"))
                Console.Error.WriteLine("Warning: Binary file name does not end with standard suffix \".lltp-x25-32.bin\".");

            Console.WriteLine("Reading binary file");
            byte[] binFileContent = File.ReadAllBytes(executableFilePath);
            uint[] MAIN_PROGRAM = ByteArrayToUIntArray(binFileContent);
            Console.WriteLine($"Decoded binary file into {MAIN_PROGRAM.Length} words.");

            Console.WriteLine("Creating virtual hardware");
            uint requiredMemoryWords = (uint)MAIN_PROGRAM.Length;
            Console.WriteLine("Creating memory object");
            RawMemory mem1 = new(requiredMemoryWords);
            Console.WriteLine("Creating text memory object");
            ConsoleMemory tmem1 = new(20);
            Console.WriteLine("Creating CPU object");
            CPU cpu = new([mem1, tmem1])
            {
                ClockLevel = false
            };

            Console.WriteLine("Loading program into memory.");
            LoadDataIntoMemory(MAIN_PROGRAM, mem1, 0x00000000u);
            mem1.Debug_DumpAll();
            Console.WriteLine("Done.");

            Console.WriteLine("\nDecide, whether to use auto or manual clock.");
            Console.WriteLine("For auto, press \"a\" key; For manual, press any other key.");
            char? input = (char)Console.Read();
            bool isAutoClock = input == 'a' || input == 'A';
            Console.WriteLine($"Auto clock enabled: {isAutoClock}");

            Console.CancelKeyPress += delegate
            {
                Console.WriteLine("\nLeaving cycle loop and exiting...");
            };

            long cycles = 0;
            // Main clock loop
            while (true)
            {
                if (!cpu.ClockLevel)
                {
                    if (!isAutoClock)
                        // Wait until the user presses enter for the next time
                        Console.ReadLine();
                    cycles++;
                    Console.WriteLine($"\n\nCPU cycle {cycles}");
                }
                // CPU clock level oscillates between low (false) and high (true)
                cpu.ClockLevel = !cpu.ClockLevel;

                Thread.Sleep(100);
            }
        }
        // Miku = 39 = Sankyuu easter egg :)
        //mem1.WriteEnable = true;
        //mem1.AddressBus = 0x00000039u;
        //mem1.DataBus = 0x39393939u;
    }

    private static void LoadDataIntoMemory(uint[] data, RawMemory mem, uint startAddress)
    {
        Console.WriteLine($"Loading {data.Length} words into memory (size {mem._words} words) starting at address {startAddress:X8}");
        if (startAddress + data.Length > mem._words)
            throw new ArgumentOutOfRangeException("Start address + Data size > Memory size");
        mem.WriteEnable = true;
        for (uint i = 0; i < data.Length; i++)
        {
            mem.AddressBus = startAddress + i;
            mem.DataBus = data[i];
        }
        Console.WriteLine("Memory write successful.");
    }

    private static uint[] ByteArrayToUIntArray(byte[] byteArray)
    {
        if (byteArray.Length % 4 != 0)
            throw new ArgumentException("Byte array length not divisible by 4.");

        uint[] uintArray = new uint[byteArray.Length / 4];
        for (int i = 0; i < uintArray.Length; i++)
        {
            uintArray[i] = BitConverter.ToUInt32(byteArray, i * 4);
        }
        return uintArray;
    }
}