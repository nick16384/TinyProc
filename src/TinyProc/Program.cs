using TinyProc.Assembler;
using TinyProc.ApplicationGlobal;

class Program
{
    // Note: This Main function should only be called when intending to run in CLI mode.
    static void Main(string[] args)
    {
        Console.WriteLine(
            $"\nTinyProc ver. {GlobalData.TINYPROC_PROGRAM_VERSION_STR} " +
            $"Processor revision {GlobalData.PROCESSOR_REVISION_VERSION_STR}");

        Console.WriteLine($"Arguments: {args.Length}");

        if (args.Length != 2
            || (!args[0].Equals("--assemble") && !args[0].Equals("--run")))
        {
            Console.Error.WriteLine(
                "Usage:\n" +
                "--assemble <Source file> : Creates a binary executable file in the same directory.\n" +
                "--run <Executable file> : Runs the executable file generated by the --assemble command.");
            return;
        }

        if (args[0].Equals("--assemble"))
        {
            string sourceFilePath = args[1];
            Console.WriteLine($"Assembling source file {sourceFilePath}");
            if (sourceFilePath.Trim().EndsWith(".lltp32.asm"))
                Console.Error.WriteLine("Warning: Source file name does not end with standard suffix \".lltp32.asm\".");
            
            string assemblyCode = File.ReadAllText(sourceFilePath);
            uint[] MAIN_PROGRAM = Assembler.AssembleToMachineCode(assemblyCode);

            string outputBinaryFilePath = sourceFilePath + ".bin";
            if (sourceFilePath.EndsWith(".asm"))
                outputBinaryFilePath = sourceFilePath[..^4] + ".bin";
            FileStream outputBinaryFileStream = File.Open(outputBinaryFilePath, FileMode.Create);
            BinaryWriter binaryWriter = new(outputBinaryFileStream);
            foreach (uint programWord in MAIN_PROGRAM)
                binaryWriter.Write(programWord);
            
            Console.WriteLine($"Binary executable file written at {outputBinaryFilePath}");
            binaryWriter.Close();
            return;
        }

        if (args[0].Equals("--run"))
        {
            string executableFilePath = args[1];
            Console.WriteLine($"Attempting to load and run binary executable {executableFilePath}");
            if (executableFilePath.Trim().EndsWith(".lltp32.bin"))
                Console.Error.WriteLine("Warning: Binary file name does not end with standard suffix \".lltp32.bin\".");

            Console.WriteLine("Reading binary file");
            byte[] binFileContent = File.ReadAllBytes(executableFilePath);
            uint[] MAIN_PROGRAM = ByteArrayToUIntArray(binFileContent);
            Console.WriteLine($"Decoded binary file into {MAIN_PROGRAM.Length} words.");

            // Extract and process header information
            uint header_AssemblerVersion = MAIN_PROGRAM[Assembler.HEADER_INDEX_VERSION];
            uint header_RAMRegionStart   = MAIN_PROGRAM[Assembler.HEADER_INDEX_RAM_REGION_START];
            uint header_RAMRegionEnd     = MAIN_PROGRAM[Assembler.HEADER_INDEX_RAM_REGION_END];
            uint header_CONRegionStart   = MAIN_PROGRAM[Assembler.HEADER_INDEX_CON_REGION_START];
            uint header_CONRegionEnd     = MAIN_PROGRAM[Assembler.HEADER_INDEX_CON_REGION_END];
            uint header_EntryPoint       = MAIN_PROGRAM[Assembler.HEADER_INDEX_ENTRY_POINT];

            // Remove header words from program
            MAIN_PROGRAM = [.. MAIN_PROGRAM.Skip(Assembler.ASSEMBLER_HEADER_SIZE_WORDS)];

            if (header_AssemblerVersion != Assembler.ASSEMBLER_VERSION_ENCODED)
            {
                string asmVersionInFile = Assembler.GetVersionStringFromEncodedValue(header_AssemblerVersion);
                string asmVersionRequired = Assembler.GetVersionStringFromEncodedValue(Assembler.ASSEMBLER_VERSION_ENCODED);
                throw new NotSupportedException(
                    $"Encoded assembler version mismatch " +
                    $"(Found: {asmVersionInFile} != Required: {asmVersionRequired})");
            }
            Console.WriteLine("Assembly version check successful!");
            
            Console.CancelKeyPress += delegate
            {
                Console.WriteLine("\nLeaving cycle loop and exiting...");
            };

            ExecutionContainer container0 = new(
                header_RAMRegionStart, header_RAMRegionEnd,
                header_CONRegionStart, header_CONRegionEnd,
                MAIN_PROGRAM, header_EntryPoint);
            
            // If this program is at this stage, it is probably running in CLI mode.
            Console.WriteLine("Program ready to execute. Press enter to start first cycle.");
            while (true)
            {
                Console.ReadLine();
                container0.StepSingleCycle();
            }
        }
    }

    private static uint[] ByteArrayToUIntArray(byte[] byteArray)
    {
        if (byteArray.Length % 4 != 0)
            throw new ArgumentException("Byte array length not divisible by 4.");

        uint[] uintArray = new uint[byteArray.Length / 4];
        for (int i = 0; i < uintArray.Length; i++)
        {
            uintArray[i] = BitConverter.ToUInt32(byteArray, i * 4);
        }
        return uintArray;
    }
}